> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s/hb1x74LTRUtrxABAkbaw9Q)

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAgrZCHjJEJjnia0BgBiapnS30IIGxyk0ibMhcQ6gL4ecbZNT6Nfed2305Q/640?wx_fmt=png)

这是我的第 58 篇原创文章

作者 | 悟空聊架构

来源 | 悟空聊架构（ID：PassJava666）

转载请联系授权（微信 ID：PassJava）

本篇主要内容如下：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAaLV8FMmPRAlr0ZOiatwM6AkjE7qfj0PiblAqxGhicqXrmCw1008Ja0VuQ/640?wx_fmt=png)

本篇主要内容

一、事务
====

1.1 什么是事务
---------

为单个工作单元而执行的一系列操作。如查询、修改数据、修改数据定义。

1.2 语法
------

**「（1）显示定义事务的开始、提交」**

```
BEGIN` `TRAN``INSERT` `INTO` `b(t1) ``VALUES``(1)``INSERT` `INTO` `b(t1) ``VALUES``(2)``COMMIT` `TRAN
```

**「（2）隐式定义」**

如果不显示定义事务的边界，则 SQL Server 会默认把每个单独的语句作为一个事务，即在执行完每个语句之后就会自动提交事务。

1.3 事务的四个属性 ACID
----------------

**「（1）原子性 Atomicity」**

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gADcOCjR9r67fpf9TyuYH4Q7sP57WU0u3n5SqIrXWv9fvemGDPMMG0xw/640?wx_fmt=png)

原子性 Atomicity**

*   1. 事务必须是`原子`工作单元。事务中进行的修改，要么全部执行，要么全都不执行；

*   2. 在事务完成之前（提交指令被记录到事务日志之前），系统出现故障或重新启动，SQL Server 将会撤销在事务中进行的所有修改；

*   3. 事务在处理中遇到错误，SQL Server 通常会`自动`回滚事务；

*   4. 少数不太严重的错误不会引发事务的自动回滚，如主键冲突、锁超时等；

*   5. 可以使用错误处理来捕获第 4 点提到的错误，并采取某种操作，如把错误记录在日志中，再`回滚`事务；

*   6.SELECT @@TRANCOUNT 可用在代码的任何位置来判断当前使用 SELECT @@TRANCOUNT 的地方是否位于一个打开的事务当中，如果不在任何打开的事务范围内，则该函数返回 0；如果在某个打开的事务返回范围内，则返回一个大于 0 的值。打开一个事务，@@TRANCOUNT=@@TRANCOUNT+1；提交一个事务，@@TRANCOUNT-1。


**「（2）一致性 Consiitency」**

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAZEqRIOGCRiaQKRAG1K9b5xuvjFv4SqtwgcuKPljcib4cDCXkf9Z3vnXQ/640?wx_fmt=png)

一致性 Consiitency

*   1. 同时发生的事务在修改和查询数据时不发生冲突；

*   2. 一致性取决于应用程序的需要。后面会讲到一致性级别，以及如何对一致性进行控制。


**「（3）隔离性 Isolation」**

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAToGwWoia384CqKDMagRmKuUoO9sqqo9HKec6Wu3y3xhXpdMbkp6TsPw/640?wx_fmt=png)

隔离性 Isolation

*   1. 用于控制数据访问，确保事务只访问处于期望的一致性级别下的数据；

*   2. 使用锁对各个事务之间正在修改和查询的数据进行隔离。


**「（4）持久性 Durability」**

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAxVaib5jeH62fia0ulva4Y5Dc10KdQdUiaMiahAYBQ3EWnwybQOFELjeoGw/640?wx_fmt=png)

持久性 Durability

*   1.**「写事务日志：」** 在将数据修改写入到磁盘上数据库的数据分区之前会把这些修改写入到磁盘上数据库的事务日志中，把提交指令记录到磁盘的事务日志中以后，即时数据修改还没有应用到磁盘的数据分区，也可以认为事务是持久化的。

*   2.**「系统重新启动：」** 正常启动或在发生系统故障之后启动，SQL Server 会每个数据库的事务日志，进行回复处理。

*   3.**「恢复处理包含两个阶段：」** 重做阶段和撤销阶段。

*   4.**「前滚：」** 在重做阶段，对于提交指令已经写入到日志的事务，但数据修改还没有应用到数据分区的事务，数据库引擎会重做这些食物所做的所有修改。

*   5.**「回滚：」** 在撤销阶段，对于提交指令没有写入到日志中的事务，数据库引擎会撤销这些事务所做的修改。（这句话需要 research, 可能是不正确的。因为提交指令没有写入到数据分区，撤销修改是指撤销哪些修改呢？）


二、锁
===

2.1 事务中的锁
---------

（1）SQL Server 使用锁来实现事务的隔离。

（2）事务获取锁这种控制资源，用于保护数据资源，防止其他事务对数据进行冲突的或不兼容的访问。

2.2 锁模式
-------

**「（1）排他锁」**![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAQ2PBL3wwXlymbEBnHApAeDpAOG9jdP4BaVMEhMh1FfUEWKeRzykQfg/640?wx_fmt=png)

排他锁

*   a. 当试图修改数据时，事务只能为所依赖的数据资源请求排他锁。

*   b. 持有排他锁时间：一旦某个事务得到了排他锁，则这个事务将一直持有排他锁直到事务完成。

*   c. 排他锁和其他任何类型的锁在多事务中不能在同一阶段作用于同一个资源。


如：当前事务获得了某个资源的排他锁，则其他事务不能获得该资源的任何其他类型的锁。其他事务获得了某个资源的任何其他类型的锁，则当前事务不能获得该资源的排他锁。

**「（2）共享锁」**![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAwR8DeEdpyHDT93lXcT1GYDMZMdPqrT1NRZ5vuEYDsToSd0BXLlRdYg/640?wx_fmt=png)

共享锁

*   a. 当试图读取数据时，事务默认会为所依赖的数据资源请求共享锁。

*   b. 持有共享锁时间：从事务得到共享锁到读操作完成。

*   c. 多个事务可以在同一阶段用共享锁作用于同一数据资源。

*   d. 在读取数据时，可以对如何处理锁定进行控制。后面隔离级别会讲到如何对锁定进行控制。


2.3 排他锁和共享锁的兼容性
---------------

（1）如果数据正在由一个事务进行修改，则其他事务既不能修改该数据，也不能读取（至少默认不能）该数据，直到第一个事务完成。

（2）如果数据正在由一个事务读取，则其他事务不能修改该数据（至少默认不能）。

2.4 可锁定的资源的类型
-------------

RID、KEY（行）、PAGE（页）、对象（例如表）、数据库、EXTENT（区）、分配单元（ALLOCATION_UNIT）、堆（HEAP）、以及 B 树（B-tree）。

**「RID: 标识页上的特定行」**

*   格式: fileid: pagenumber: rid （1:109:0 ）


其中 fileid 标识包含页的文件， pagenumber 标识包含行的页，rid 标识页上的特定行。

fileid 与 sys.databases_files 目录视图中的 file_id 列相匹配

*   例子：


在查询视图 sys.dm_tran_locks 的时候有一行的 resource_description 列显示 RID 是 1:109:0 而 status 列显示 wait,

表示第 1 个数据文件上的第 109 页上的第 0 行上的锁资源。

2.5 锁升级
-------

SQL Server 可以先获得`细粒度`的锁（例如行或页），在某些情况下将细粒度锁升级为`更粗粒度`的锁（例如，表）。  
例如单个语句获得至少 5000 个锁，就会触发锁升级，如果由于锁冲突而导致无法升级锁，则 SQL Server 每当获取 1250 个新锁时出发锁升级。

三、阻塞
====

3.1 阻塞
------

当多个事务都需要对某一资源进行`锁定`时，默认情况下会发生阻塞。被阻塞的请求会一直等待，直到原来的事务释放相关的锁。锁定`超时期限`可以限制，这样就可以限制被阻塞的请求在超时之前要`等待的时间`。

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAx3aMVLseicGZJ8aEfQ7evFt7bx8sNOYz77HFFILmiccbwGWdicIia4dcgA/640?wx_fmt=png)

阻塞

*   阶段 1：事务 A 请求资源 S1，事务不对资源 S1 进行操作

*   阶段 2：事务 A 用锁 A 锁定资源 S1，事务 B 请求对资源 S1 进行不兼容的锁定（锁 B）, 锁 B 的请求被阻塞，事务 B 将进入等待状态

*   阶段 3：事务 A 正在释放锁 A，事务 B 等待锁 A 释放，

*   阶段 4：事务 A 的锁 A 已释放，事务 B 用锁 B 锁定资源 S1


3.2 排除阻塞问题
----------

例子：

#### 3.2.1 准备工作：

*   1. 准备测试数据


```
--先创建一张表Product作为测试。id为表的主键，price为product的价格
CREATE TABLE [dbo].[myProduct](
    [id] [int] NOT NULL,
    [price] [money] NOT NULL
) ON [PRIMARY]
GO
--插入一条数据，id=1,price=10
INSERT INTO [TSQLFundamentals2008].[dbo].[myProduct]([id],[price])VALUES(1,10)
```

*   2. 模拟阻塞发生的情况


在 SQL Server 中打开三个查询窗口 Connection1、Connection2、Connection3，分别按顺序执行表格中的执行语句。

```
--Connection1
BEGIN TRAN
UPDATE dbo.myProduct SET price = price + 1 WHERE id=1
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gADzstMowWpVk0V5Tkz6u7fLdYMRps5CKDorOHQibr9yvV0thg02iceztQ/640?wx_fmt=png)

Connection1 结果

**「结论 1：」**

为了更新 id=1 这一行数据，会话必须先获得一个排他锁。事务处于一直打开状态，没有提交，所以事务一直持有排他锁，直到事务提交并完成。

```
--Connection2
SELECT * FROM dbo.myProduct WHERE id=1
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAODYyswbEQ34CESBN8V8GVwUDckNHPn1NykAuc5ePSfKguhLic7oc4Vg/640?wx_fmt=png)

Connection2 结果

**「结论 2：」**

事务为了读取数据，需要请求一个共享锁，但是这一行已经被其他会话持有的排他锁锁定，而且共享锁和排他锁不是兼容的，所以会话被阻塞，进入等待状态

```
--Connection3
SELECT  request_session_id AS 会话id ,
        resource_type AS 请求锁定的资源类型 ,
        resource_description AS 描述 ,
        request_mode AS 模式 ,
        request_status AS 状态
FROM    sys.dm_tran_locks
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gA6NxgmS0oEFibiaNYNwWvILHEX7ZMIXhnzAAS9weCMfpyuz9DRzpnicStg/640?wx_fmt=png)

Connection3 查询结果

****「结论 3：」****

**「会话 56：」**（1）状态 WAIT - 等待锁

（2）正在等待第 1 个数据文件上的第 109 页上的第 0 行资源的共享锁

（3）持有第 1 个数据文件上的第 109 页资源的意向共享锁

（3）持有 OBJECT 资源，意向共享锁

（4）持有 DATABASE 资源，意向共享锁

**「会话 52：」**

（1）状态 WAIT - 授予锁

（2）正在等待第 1 个数据文件上的第 109 页上的第 0 行资源的排他锁（3）持有第 1 个数据文件上的第 109 页资源的排他锁

（3）持有 OBJECT 资源，排他锁

（4）持有 DATABASE 资源，排他锁

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAqXtb78ibibcXexOR7kCjopryAwKFetCHgxhE7jZ1HQMQXWfveUaONnEw/640?wx_fmt=png)

演示与总结

### 3.2.2 分析阻塞原因

#### 3.2.2.1 sys.dm_tran_locks 视图

（1）该动态视图可以查询出哪些资源被哪个进程 ID 锁了

（2）查询出对资源授予或正在等待的锁模式

（3）查询出被锁定资源的类型

上面的查询语句 3 已经用到了这个视图，可以参考上图中的分析说明。

#### 3.2.2.2 sys.dm_exec_connections 视图

（1）查询出该动态视图可以查询出进程相关的信息

（2）查询出最后一次发生读操作和写操作的时间 last_read,last_write

（3）查询出进程执行的最后一个 SQL 批处理的二进制标记 most_recent_sql_handle

```
SELECT  session_id ,
        connect_time ,
        last_read ,
        last_write ,
        most_recent_sql_handle
FROM    sys.dm_exec_connections
 
WHERE   session_id IN ( 52, 56 )
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gA49wZ8tm1dGhJGuFDpOUCJeSa91k2Kkd8Nrm5zAb0qqXIxVG7uwZEgg/640?wx_fmt=png)

查询结果 1

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gA5cia0D3tH2rYz5ARkrgg7hEiax2D7gOxibfpfS5yD863icWM5ibXz2RkB2Q/640?wx_fmt=png)

查询结果 2

**「结论：」**

**「会话 52：」**

（1）connect_time 连接时间：2016-06-07 07:09:41.103

（2）last_read 最后一次读操作时间：2016-06-07 07:10:56.233

（3）last_write 最后一次写操作时间：2016-06-07 07:10:57.873

（4）most_recent_sql_handle 这是一个二进制标记，最后一个 SQL 批处理

**「会话 56：」**

（1）状态 WAIT - 授予锁

（2）正在等待第 1 个数据文件上的第 109 页上的第 0 行资源的排他锁（3）持有第 1 个数据文件上的第 109 页资源的排他锁

（3）持有 OBJECT 资源，排他锁

（4）持有 DATABASE 资源，排他锁

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAC68KVCCUasCQ1VkDxTdXic6DTibVlkYnblK855YkVv5mocyPtbqK7nsg/640?wx_fmt=png)

演示与总结

#### 3.2.2.3 sys.dm_exec_sql_text 表函数

示例：

```
会话52：
执行的SQL语句：
BEGIN TRAN
UPDATE dbo.myProduct
SET price = price + 1
WHERE id = 1

会话56：
执行的SQL语句：
(@1 tinyint)
SELECT * FROM [dbo].[myProduct]
WHERE [id]=@1
```

（1）该函数可以将二进制标记 most_recent_sql_handle 作为参数，然后返回 SQL 代码。

（2）阻塞进程在不断地运行，所以在代码中看到的最后一个操作不一定是导致问题的语句。在本例中最后一条执行语句是导致阻塞的语句。

```
SELECT  session_id ,
        text
FROM    sys.dm_exec_connections
        CROSS APPLY sys.dm_exec_sql_text
        (most_recent_sql_handle) AS ST
WHERE   session_id IN ( 52, 56 )
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAbROTOQXibxkmLXYwfVavn4ZbZPn2uYicAby5YkPA9iaaeoLujmujDYia3Q/640?wx_fmt=png)

查询结果

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAicYxX7nE5v72Kwico7Gd8DnDtR8GQRaaiamMX96nX1NsqzSYjz63QicuJA/640?wx_fmt=png)

演示与总结

#### 3.2.2.4 sys.dm_exec_sessions 视图

（1）会话建立的时间 login_time

（2）特定于会话的客户端工作站名称 host_name

（3）初始化会话的客户端程序的名称 program_name

（4）会话所使用的 SQL Server 登录名 login_name

（5）最近一次会话请求的开始时间 last_request_start_time

（6）最近一次会话请求的完成时间 last_request_end_time

```
SELECT * FROM sys.dm_exec_sessions
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAM8xwlQcoBCoCvSD7PrtrNTHc0BUDj8gpqSNHLqeiczh5DD9vOAAM5kQ/640?wx_fmt=png)

查询结果

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAaGYtp25cfLE1zwRHUq8EJPkPteqsI1qdbYDpOvn1JRQSXoH5je05Vg/640?wx_fmt=png)

演示与总结

#### 3.2.2.5 sys.dm_exec_requests 视图

（1）识别出阻塞链涉及到的会话、争用的资源、被阻塞会话等待了多长时间

```
SELECT * FROM sys.dm_exec_sessions
```

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAGIX17OyjQCJYycIX4IpUcbP2572cQMLFle4ceh0pGNPicWC9H95OOsA/640?wx_fmt=png)

查询结果 1

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gA7VQG3PL3uJ10WVv5YhUJv4WL3x1llR3Mc7gdrJZuhV8D2sQuaW4fUQ/640?wx_fmt=png)

查询结果 2

**「结论：」**

**「会话 56：」**

（1）被会话 52 阻塞，blocking_session_id = 52

（2）会话 52 的开始时间 start_time

（3）状态挂起 status = suspended

（4）挂起的命令 command

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAbpEbyRTeBV1DhlJq2pbgnibic9xddD2RJXmclCDanFd8aRenmhFCaSWA/640?wx_fmt=png)

演示与总结

### 3.2.3 解决阻塞问题

#### 3.2.3.1 Lock_TIMEOUT 选项

（1）设置会话等待锁释放的超时期限

（2）默认情况下会话不会设置等待锁释放的超时期限

（3）设置会话超时期限为 5 秒， SET Lock_TIMEOUT 5000

（4）锁定如果超时，不会引发事务回滚

（5）取消会话超时锁定的设置，SET LOCK_TIMEOUT -1

如果超时，将显示以下错误：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAaU6ibzNG8xa8VeZPAyhP5DGREElCcc1vmJUSUic1eBlfaaO273WT602A/640?wx_fmt=png)

错误提示

#### 3.2.3.1 KILL 命令

（1）杀掉会话 52，KILL 52

（2）杀掉会话，会引起事务回滚，同时释放排他锁

四、隔离级别
======

4.1 基本概念
--------

**「（1）隔离级别用来做什么」**

*   a. 隔离级别用于决定如何控制并发用户读写数据的操作


**「（2）写操作」**

*   a. 任何对表做出修改的语句

*   b. 使用排他锁

*   c. 不能修改读操作获得的锁和锁的持续时间


**「（3）读操作：」**

*   a. 任何检索数据的语句

*   b. 默认使用共享锁

*   c. 使用隔离级别来控制读操作的处理方式


4.2 隔离级别的分类
-----------

（1）未提交读 （READ UNCOMMITTED）

（2）已提交读（READ COMMITTED）（默认值）

（3）可重复读（REPEATABLE READ）

（4）可序列化（SERIALIZABLE）

（5）快照（SNAPSHOT）

（6）已经提交读快照（READ_COMMITTED_SNAPSHOT）

4.3 隔离级别的设置
-----------

**「（1）设置整个会话的隔离级别」**

```
SET TRANSACTION ISOLATION LEVEL <isolation name>;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

**「（2）用表提示设置查询的隔离级别」**

```
SELECT ... FROM <table> WITH (<isolation name>);
SELECT * FROM dbo.myProduct WITH (READCOMMITTED);
```

注意：

*   1. 设置会话选项的隔离级别时，隔离级别中的每个单词之间需要用空格分隔

*   2. 用表提示的隔离级别时，隔离级别中的每个单词之间不需要用空格分隔

*   3. 表提示的隔离级别有同义词，如：NOLOCK->READUNCOMMITTED,HOLDLOCK->REPEATABLEREAD

*   4. 隔离级别的严格性：**1. 未提交读 < 2. 已提交读 < 3. 可重复读 < 4. 可序列化**

*   5. 隔离级别越高，一致性越高，并发性越低

*   6. 基于快照的隔离级别，SQL Server 将提交过的行保存到 tempdb 数据库中，当读操作发现行的当前版本和它们预期的不一致时，可以立即得到行的以前版本，从而不用请求共享锁也能取得预期的一致性。


4.4 隔离级别的行为方式
-------------

### 4.4.1 未提交读 （READ UNCOMMITTED）

打开两个查询窗口，Connetion1,connection2

*   Step1: 执行 Connection1 的阶段 2 的 SQL 语句，然后执行 connection2 的 SQL 语句

*   Step2: 执行 Connection1 的阶段 3 的 SQL 语句，执行 connection2 的 SQL 语句

*   Step3: 执行 Connection1 的阶段 4 的 SQL 语句，执行 connection2 的 SQL 语句


```
--阶段2
UPDATE  myProduct
SET     price = price + 1
WHERE   id = 1;
  
SELECT  id ,
        price
FROM    dbo.myProduct
WHERE   id = 1;
  
--阶段3
UPDATE  myProduct
SET     price = price + 5
WHERE   id = 1;
  
SELECT  id ,
        price
FROM    dbo.myProduct
WHERE   id = 1;
  
--阶段4
COMMIT TRAN
```

```
--在阶段2执行之后
SET TRAN ISOLATION LEVEL READ UNCOMMITTED
BEGIN TRAN;
SELECT  id ,
        price
FROM    dbo.myProduct
WHERE   id = 1
 
COMMIT TRAN;
```

两个事务的流程图：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAIu1eLdWq24CaiaWR9UbSYyBWkkKPeL23K1T7dFq16xHdcHu5K7IcdDw/640?wx_fmt=png)

1. 未提交读 READ UNCOMMITTED

*   阶段 1：Price=10, 事务 A 对 myProduct 表请求排他锁

*   阶段 2：事务 A 对 myProduct 表使用了排他锁，更新 price = price + 1，然后事务 A 查询 price 的价格: price=11。事务 B 不请求任何锁，事务 B 在 A 更新 Price 之后进行查询，price=11

*   阶段 3：事务 A 更新 price = price + 5，然后事务 A 查询 price 的价格，price = 16。事务 B 查询 price 的价格: price=16

*   阶段 4：事务 A 释放排他锁

*   阶段 5：事务 A 中查询 price 的价格: price = 16。事务 B 查询 price 的价格: price=16


**「大家可以看到事务 B 有两种结果，这就是 “未提交读 （READ UNCOMMITTED）” 隔离级别的含义：」**

（1）读操作可以读取未提交的修改（也称为脏读）。

（2）读操作不会妨碍写操作请求排他锁，其他事务正在进行读操作时，写操作可以同时对这些数据进行修改。

（3）事务 A 进行了多次修改，事务 B 在不同阶段进行查询时可能会有不同的结果。

### 4.4.2 已提交读（READ COMMITTED）（默认值）

打开两个查询窗口，Connetion1,connection2

Step1: 执行 Connection1 的 SQL 语句

```
UPDATE` `dbo.myProduct ``SET` `price = price + 1 ``WHERE` `id=1
SELECT` `* ``FROM` `dbo.myProduct ``WHERE` `id =1
```

Step2: 执行 Connection2 的 SQL 语句

```
SET` `TRANSACTION` `ISOLATION` `LEVEL` `READ` `COMMITTED
SELECT` `* ``FROM` `dbo.myProduct ``WHERE` `id = 1
```

两个事务的流程图：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gArq9P75asDW1e1hxHhXLP54EDtzXpYS0PdNwlaGhLy7C7SMHQ5FEFHA/640?wx_fmt=png)

4.2.2. 已提交读 READ COMMITTED

*   阶段 1：Price=10, 事务 A 对 myProduct 表请求排他锁

*   阶段 2：事务 A 对 myProduct 表使用了排他锁，更新 price = price + 1，然后事务 A 查询 price 的价格: price=11。然后事务 B 请求共享锁进行读操作，查询 price，


由于在当前隔离级别下，事务 A 的排他锁和事务 B 的共享锁存在冲突，所以事务 B 需要等待事务 A 释放排他锁后才能读取数据。

*   阶段 3：事务 A 提交事务（COMMIT TRAN）

*   阶段 4：事务 A 提交完事务后，释放排他锁

*   阶段 5：事务 B 获得了共享锁，进行读操作，price=11

    **「“已提交读 （READ UNCOMMITTED）” 隔离级别的含义：」**


（1）必须获得共享锁才能进行读操作，其他事务如果对该资源持有排他锁，则共享锁必须等待排他锁释放。

（2）读操作不能读取未提交的修改，读操作读取到的数据是提交过的修改。

（3）读操作不会在事务持续期间内保留共享锁，其他事务可以在两个读操作之间更改数据资源，读操作因而可能每次得到不同的取值。这种现象称为 “不可重复读”

### 4.4.3 可重复读（REPEATABLE READ）

打开两个查询窗口，Connetion1,connection2

Step1: 执行 Connection1 的 SQL 语句

```
SET` `TRANSACTION` `ISOLATION` `LEVEL` `REPEATABLE` `READ
SELECT` `* ``FROM` `dbo.myProduct ``WHERE` `id = 1
```

Step2: 执行 Connection2 的 SQL 语句

```
UPDATE` `dbo.myProduct ``SET` `price = price + 1 ``WHERE` `id=1   
```

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gATadHvrqG3XVHs3jO4Kic4SulOic0cfvVX1bePc9vD6vrrYSzdwGuyWXw/640?wx_fmt=png)

演示与总结

两个事务的流程图：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAyvcfA51SahyFCyT2WPMib0hBULI8VN25gAeGQjzFeLCRxSYSzWaqG6A/640?wx_fmt=png)

4.4.3. 可重复读 REPEATABLE READ

*   阶段 1：Price=10, 事务 A 对 myProduct 表请求共享锁

*   阶段 2：事务 A 对 myProduct 表使用了共享锁，事务 A 查询 price 的价格: price=10，事务 A 一直持有共享锁直到事务 A 完成为止。然后事务 B 请求排他锁进行写操作 price=price+1，


由于在当前隔离级别下，事务 A 的共享锁和事务 B 请求的排他锁存在冲突，所以事务 B 需要等待事务 A 释放共享锁后才能修改数据。

*   阶段 3：事务 A 查询 price, price=10, 说明事务 B 的更新操作被阻塞了，更新操作没有被执行。然后事务 A 提交事务（COMMIT TRAN）

*   阶段 4：事务 A 提交完事务后，释放共享锁

*   阶段 5：事务 B 获得了排他锁，进行写操作，price=11


**“可重复读 （REPEATABLE READ）” 隔离级别的含义：  **

（1）必须获得共享锁才能进行读操作，获得的共享锁将一直保持直到事务完成之止。

（2）在获得共享锁的事务完成之前，没有其他事务能够获得排他锁修改这一数据资源，这样可以保证实现可重复的读取。

（3）两个事务在第一次读操作之后都将保留它们获得的共享锁，所以任何一个事务都不能获得为了更新数据而需要的排他锁，这种情况将会导致死锁（deadlock），不过却避免了更新冲突。

### 4.4.4 可序列化（SERIALIZABLE）

打开两个查询窗口，Connetion1,connection2  
Step1: 执行 Connection1 的 SQL 语句

```
BEGIN TRANSACTION
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE   
SELECT * FROM dbo.myProduct WHERE id = 1
```

Step2: 执行 Connection2 的 SQL 语句

```
INSERT` `INTO` `dbo.myProduct(id, price) ``VALUES` `(1, 20)
```

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAZFH7v4AsiczwGLFLrXLqGRuqIXY3NC8Ta1YxiaXBAk8N8oO4Eg2jvKBQ/640?wx_fmt=png)

演示与总结

两个事务的流程图：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAUrI8z4LkUmkOW5SxTcbHtqEZxN34HcRE9eIdkHJ4SWPDFHOIa2KESA/640?wx_fmt=png)

4.4.4. 可序列化 SERIALIZABLE

*   阶段 1：Price=10, 事务 A 对 myProduct 表请求共享锁

*   阶段 2：事务 A 对 myProduct 表使用了共享锁，事务 A 查询 id=1 的 price 的价格: 1 行记录，price=10，事务 A 一直持有共享锁直到事务 A 完成为止。然后事务 B 请求排他锁进行插入操作 id=1,price=20，


由于在当前隔离级别下，事务 B 试图增加能够满足事务 A 的读操作的查询搜索条件的新行，所以事务 A 的共享锁和事务 B 请求的排他锁存在冲突，事务 B 需要等待事务 A 释放共享锁后才能插入数据。

*   阶段 3：事务 A 查询出 id=1 的数据只有 1 行，说明事务 B 的插入操作被阻塞了，插入操作没有被执行。然后事务 A 提交事务（COMMIT TRAN）

*   阶段 4：事务 A 提交完事务后，释放共享锁

*   阶段 5：事务 B 获得了排他锁，进行插入操作，插入成功，查询出 id=1 的数据有两条 -


**「“可序列化（SERIALIZABLE）” 隔离级别的含义：」**

（1）必须获得共享锁才能进行读操作，获得的共享锁将一直保持直到事务完成之止。

（2）在获得共享锁的事务完成之前，没有其他事务能够获得排他锁修改这一数据资源，且当其他事务增加能够满足当前事务的读操作的查询搜索条件的新行时，其他事务将会被阻塞，直到当前事务完成然后释放共享锁，其他事务才能获得排他锁进行插入操作。

（3）事务中的读操作在任何情况下读取到的数据是一致的，不会出现幻影行（幻读）。

（4）范围锁：读操作锁定满足查询搜索条件范围的锁。

4.5 隔离级别总结
----------

**「脏读：」** 读取未提交的更改。

**「不可重复读：」** 读操作不会在事务持续期间内保留共享锁，其他事务可以在两个读操作之间更改数据资源，读操作因而可能每次得到不同的取值。

**「丢失更新：」** 两个事务进行读操作，获得资源上的共享锁，读取完数据后，不再持有资源上的任何锁，两个事务都能更新这个值，最后进行更新的事务将会覆盖其他事务做的更改，导致其他事务更改的数据丢失。

**「幻读：」** 第一次和第二次读取到的数据行数不一致。

**「范围锁：」** 读操作锁定满足查询搜索条件范围的锁

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAY5ZVDlJdYtwSmbvUBAbp8ibg2ZibrJJgmaWojQHG9RyLHa4xI8K94doA/640?wx_fmt=png)

隔离级别总结

五. 死锁
=====

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAAcicmxtwdibZLllPv1dcequephKC1fDicptG4Tf8DJ5yHq8Biaq6rX3mag/640?wx_fmt=png)

死锁

死锁是指一种进程之间互相永久阻塞的状态，可能涉及两个或更多的进程。

打开两个查询窗口，Connetion1,connection2

Step1: 执行 Connection1 的 SQL 语句

```
SET` `TRANSACTION` `ISOLATION` `LEVEL` `READ` `COMMITTED
BEGIN` `TRAN
UPDATE` `dbo.myProduct ``SET` `price = price + 1 ``WHERE` `id=1
SELECT` `* ``FROM` `dbo.myOrder ``WHERE` `id =1
```

Step2: 执行 Connection2 的 SQL 语句

```
SET` `TRANSACTION` `ISOLATION` `LEVEL` `READ` `COMMITTED
BEGIN` `TRAN
UPDATE` `dbo.myOrder ``SET` `customer = ``'ddd'` `WHERE` `id = 1
SELECT` `* ``FROM` `dbo.myProduct ``WHERE` `id = 1
```

演示与总结如下所示：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAuk3u2XbdWRDxsS0ofsfXYwfvCwfqxwADYaTd889kEAaF7g8BdZ284A/640?wx_fmt=png)

演示与总结

两个事务的流程图：

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gAGRYibB8iccheGtlEGcOw5LN03dXfT103lYpTibpGtQ2C4bWu5h7sITaZA/640?wx_fmt=png)

5. 死锁 Dead Lock

*   阶段 1：Price=10, 事务 A 对 myProduct 表请求排他锁。Customer = aaa, 事务 B 对 myOrder 请求排他锁

*   阶段 2：事务 A 对 myProduct 表使用了排他锁，更新 price = price + 1。然后事务 B 对 myOrder 表使用了排他锁，更新 customer=ddd。

*   阶段 3：事务 A 查询 myOrder 表，对 myOrder 表请求共享锁，因为事务 A 的请求的共享锁与事务 B 的排他锁冲突，所以事务 A 被阻塞。然后事务 B 查询 myProduct 表，对 myProduct 表请求共享锁，因为事务 B 的请求的共享锁与事务 A 的排他锁冲突，所以事务 B 被阻塞。

*   阶段 4：事务 A 等待事务 B 的排他锁释放，事务 B 等待事务 A 的排他锁释放，导致死锁。事务 A 和事务 B 都被阻塞了。

*   阶段 5：SQL Server 在几秒之内检测到死锁，会选择一个事务作为死锁的牺牲品，终止这个事务，并回滚这个事务所做的操作。在这个例子中，事务 A 被终止，提示信息：事务 (进程 ID 53) 与另一个进程被死锁在 锁 资源上，并且已被选作死锁牺牲品。请重新运行该事务。


“**「死锁 （Dead Lock）」**” 的一些注意事项：

（1）如果两个事务没有设置死锁优先级，且两个事务进行的工作量也差不多一样时，任何一个事务都有可能被终止。

（2）解除死锁要付出一定的系统开销，因为这个过程会涉及撤销已经执行过的处理。

（3）事务处理的时间时间越长，持有锁的时间就越长，死锁的可能性也就越大，应该尽可能保持事务简短，把逻辑上可以不属于同一个工作单元的操作移到事务以外。

（4）上面的例子中，事务 A 和事务 B 以相反顺序访问资源，所以发生了死锁。如果两个事务按同样的顺序来访问资源，则不会发生这种类型的死锁。在不改变程序的逻辑情况下，可以通过交换顺序来解决死锁的问题。

我是悟空，一只努力变强的码农！我要变身超级赛亚人啦！

![](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2JMMcLXb6ekEN7hXickm8gArwz96NEq6dAxAUwibh0JyybcXEcpWjwJhXYLCrE9icqHXv0OJqbK2RFA/640?wx_fmt=png)

我的资料

> ❝
>
> 你好，我是`悟空哥`，**「7 年项目开发经验，全栈工程师，开发组长，超喜欢图解编程底层原理」**。正在编写两本 PDF，分别是 1、Spring Cloud 实战项目（佳必过），2、Java 并发必知必会。我还`手写了2个小程序`，Java 刷题小程序，PMP 刷题小程序，点击我的公众号菜单打开！另外有 111 本架构师资料以及 1000 道 Java 面试题，都整理成了 PDF，可以关注公众号 悟空聊架构 回复 `悟空` 领取优质资料。
>
> ❞

**「转发 -> 在看 -> 点赞 -> 收藏 -> 评论！！！」**  是对我最大的支持！

- END -

更多内容

*   [**和 JavaGuide 作者面基是种什么体验？**](http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451944329&idx=1&sn=fed3afc59eb2242920d9a5bfac74f706&chksm=8d1c4a16ba6bc30091213bf0fbbdfea748942f9c44e5a2c6b7a206c8af5a120bde39d997733b&scene=21#wechat_redirect)

*   [全网最细 | 21 张图带你领略集合的线程不安全](http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451944303&idx=1&sn=6fc5a3198e4216eed667a26648028b71&chksm=8d1c4af0ba6bc3e6c5b4638c8e33deac79f8646343a03ba44e10dcb14a0eeb7095f437e9c554&scene=21#wechat_redirect)

*   [Java 并发必知必会第三弹：用积木讲解 ABA 原理](http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451944205&idx=1&sn=472fab10dda17168a7a7b14a5f9e9ac7&chksm=8d1c4a92ba6bc3849eebbd925009e0d61593fa8e3dd9a087725ffa55c0f3a38c3bb7646db83f&scene=21#wechat_redirect)

*   [程序员深夜惨遭老婆鄙视，原因竟是 CAS 原理太简单？](http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451944151&idx=1&sn=72d2bed49284d56d1e758fcdaa1c18fa&chksm=8d1c4b48ba6bc25e831085e95ad29a2b1e5a29218368fe058331e2ebcdf407890c41854a5082&scene=21#wechat_redirect)

*   [5000 字 | 24 张图带你彻底理解 Java 中的 21 种锁](http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&mid=2451944398&idx=1&sn=4e9bd51a668ff4be2f1abd3183bc5b9c&chksm=8d1c4a51ba6bc3479b17b88548295b4f1b84d7524e15fd7692e6ae467b0276a651837d8b0428&scene=21#wechat_redirect)


![图片](https://mmbiz.qpic.cn/mmbiz_png/iaJMGsgPepR8G0cGYxKibKibYEsX9WLx2xkWINTiapL0I1GumsOsgkgUKsAo8glF1CykLNlXOD7Dxb0FYIicTo155Mg/640?wx_fmt=png)



![图片](https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ1dOibNFIxicn9UsCeBXjiaDFicWaC25wpC3eCyGX1icLlbGvQKO8xicQ8vvMWjiawMPEVjygia2QXuUhib6qA/640?wx_fmt=png)

![图片](https://mmbiz.qpic.cn/mmbiz_png/iaJMGsgPepR8G0cGYxKibKibYEsX9WLx2xkWINTiapL0I1GumsOsgkgUKsAo8glF1CykLNlXOD7Dxb0FYIicTo155Mg/640?wx_fmt=png)

**长按二维码关注**

**领取架构师资料**

点亮，服务器三年不宕机![](https://mmbiz.qpic.cn/mmbiz_gif/wtIePIKFibDaPibPt5PE37xRibz7Fy3WDtFj1UMvmC91LcBw5C8iakNUOlbG1OxGaEARs4qR88BfvqwJVIY88xe6kA/640?wx_fmt=gif)