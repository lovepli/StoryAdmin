> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [mp.weixin.qq.com](https://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247488866&idx=1&sn=fcd7ed1114eba05c12363500fbc9f193&scene=21#wechat_redirect)

上一篇写了一篇关于刷 **《深入 JVM 虚拟机 第三版》** 书的个人经验，颇受好评，也有挺多从掘金过来的朋友，没看过并且有兴趣的可以看一看：[三天刷完《深入 JVM 虚拟机 第三版》是什么感觉](http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247488849&idx=1&sn=e19874cffb6f62002bae055272b72807&chksm=fbf7fc93cc8075857bc1b79f5df11dde6c65c7dac35ed48e1a79a47748e83ebd93d1ee63813f&scene=21#wechat_redirect)

这一篇就来聊一聊 GC，聊聊我们的垃圾回收器，我们知道 Java 的垃圾回收机制与 C++ 的有所不同，作为 **Java 程序员不用在程序中自己释放内存，自己去管理内存**，对于内存使用似乎是 “肆无忌惮” 一样。

然而，这背后一切的原因就是 JVM 的 GC 已经帮我们做了这些事，能够帮我们自动管理这些事，当内存紧张的时候，就会触发垃圾回收机制，腾出足够的空间来供我们程序使用。

但是，JVM 的 GC 也不是万能的，也有翻车的时候，比如碰到过**内存泄露**的时候，就会导致 **GC 的内存回收的效率低下，甚至出现 OOM 的异常**。

作为 Java 程序员，我们要做的就是要保证 GC 正常工作，基于这种情况下对于 **GC 的工作的原理**和 **GC 的使用的场景**就得有所了解。

下面就开始我们的正文，这里我画了一个介绍这篇文章主要内容的思维导图：

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WphUJmFY9dUB00IqdScdrQricoqkxibk3ubTQsMv6xiadPXpZRI2iaBsbDA/640?wx_fmt=png)

首先先来聊聊哪些对象应该被 GC，JVM 是怎么判断一个对象是否存活的呢？

### 判断对象存活

想要判断对象是否存活，有两种方法：

1.  引用计数法

2.  可达性分析算法


#### 引用计数法

第一个引用计数法实现简单，效率高。它的原理就是在**对象内部维护一个计数器，当有地方引用它的时候，计数器 + 1，当有地方不再引用它的时候，计数器 - 1**。

就这样，当计数器为零的时候，表示没有地方引用它，那么这个对应就应该要被 GC 回收了。

但是这种算法却很少被 Java 虚拟机使用，主要原因是它有漏洞：**无法解决循环引用的问题**：

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WTMSYbZCJLHxysI2fvFEsLEw6boTLLMzQQ53fAejvPdye6A1rE4Fd8Q/640?wx_fmt=png)

#### 可达性分析算法

第二种就是可达性分析算法，它是以一组 GCRoots 为起点，根据引用链的关系向下搜索，若是某个对象与 GCRoot 之间没有任何的引用链，则这个对象是不可达的，也是将来会被回收掉的。

这种算法被引用在主流的 Java 虚拟机中，比如 HotSpot，那哪些对象可以作为 GCRoots 呢？主要有以下的对象可以作为 GCRoots：

*   **虚拟栈中引用的对象。**

*   **方法区中的静态变量。**

*   **方法区中的常量。**

*   **以及本地方法栈 JNI 引用的对象（这个可以忽略，我们几乎没有接触）。**


以上比较常见的就是方法区中的静态变量和常量的引用对象，知道了怎么判断对象是否存活，下面就是用可达性分析算法，用到具体的垃圾回收算法上。

### 垃圾回收算法

对于垃圾回收算法，我这里就不做过于详细的介绍，就简单介绍一下，因为之前已经写过一篇比较详细的文章了，大家可以参考一下：[还在学 JVM？我都帮你总结好了（附脑图）](http://mp.weixin.qq.com/s?__biz=MzU1MzE4OTU0OQ==&mid=2247483948&idx=1&sn=ee9b3ad4dd1dadd174984d1cedb5760a&chksm=fbf7ebeecc8062f8dfe2df001d0f82c4b24f03c6523b0ac5cb15466866c01e29d570ce26c6fb&scene=21#wechat_redirect)

常见的垃圾回收算法就这三种：

1.  **标记 - 清除**

2.  **复制算法**

3.  **标记 - 整理（压缩算法）**


我们知道**年轻代基本都是朝生夕死，所以都是使用复制算法**，复制的成本低，基于这种分代模型理论，也就出现了后面垃圾回收器的 **Eden 区、From Survivor 区、To Survivor 空间（默认 8:1:1）**。

新生代中每次都只有 Eden 和其中的一个 S 区可用，当 Eden 区满了，就会将存活的对象复制到其中的一个 S 区中，若是 S 区也满了，此区域不满足晋升条件的对象就会被复制到到另一个 S 区中。就这样对象每经历一次 Minor GC 年龄就会 + 1，当达到晋升年龄的阈值，对象还没被垃圾回收掉，就会被放入；老年代。

而**老年代使用的是标记 - 清除或者标记 - 整理**，对于标记 - 清除我们知道它最大的缺点就是会产生内存碎片，但是他也有自己的好处（相比标记 - 整理），就是不用移动对象，所以效率相比标记 - 整理要高。

而标记 - 整理完整的过程应该是**标记 - 整理 - 清除**三个步骤，需要将存活的对象向一边移动，然后清理掉不可达的对象，所以它的效率也会比较低，**尤其是老年代这种区域，有大量的对象存活，那么对于移动对象所耗费的性能也是可观的**。

还有一点比较重要的是：**新生对象的内存分配的角度**。这个是很多技术博文都忽略的一点，这一点也是比较重要的，在《深入 JVM 虚拟机 第三版》中也有特别强调这一点。

从内存分配的角度来看：**对于标记 - 整理和复制算法，都是整理的规整空间，所以他们俩对于新产生的对象进行分配内存的时候，是比较简单高效的，特别是对于一些大对象的分配以及连续内存对象的分配（数组）**。

标记 - 整理和复制算法只需要内存地址指针移动与对象一样大小的位置，便可完成内存分配，这样高效简单。

而对于标记 - 清除法，因为产生了内存碎片，所以它必须要记住哪些地方是可用的，哪些地方是不可用的，这样内存分配的效率就会低很多。

知道了具体的垃圾回收算法，下面就来聊聊具体的垃圾回收器。

### 垃圾回收器

根据分离代理模型，对于不同的区域设计出了不同的垃圾回收器，对于经典的垃圾回收器主要有这么几种：

*   **Serial（新生代）**

*   **SerialOld（老年代）**

*   **PS（新生代）**

*   **PO（老年代）**

*   **ParNew（新生代）**

*   **CMS（老年代）**

*   **G1**


对于以上几种的垃圾回收器，可以选择不同的老年代和年轻代进行搭配使用，主要有以下的搭配方式：

![](https://mmbiz.qpic.cn/mmbiz_jpg/IJUXwBNpKljT9sbQfecxEhZoG86jKs3Wib328iczh3CEAvHlicyLicoq3u8M96DNB1jJuxOFFCoJ7XgOoH4rict7MiaA/640?wx_fmt=jpeg)

#### Serial

Serial 系列的垃圾回收器，现在也基本没人用了，它的使用原理**就是使用单线程来进行垃圾回收，所以 STW 的时间也会比较长，实现简单**。**老年代的 SerialOld 使用的是标记 - 整理**的算法来回收垃圾。

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WgMjp9QIOxW4iaHkSt8UAbQjzWPicS8MYWvHqODIoezwl9YvmTJ3frBOw/640?wx_fmt=png)

来源于深入 JVM 虚拟机

在若是你的服务器还处在单核时代，内存只有那么**几十 M 到百来 M**，可能 Serial 是最优的搭配选择。

对于 Serial 的相关 JVM 参数有：**-XX:+UseSerialGC**（使用 Serial 垃圾回收器）。

#### Parallel

当发展到多线程时代，PS 和 PO 的搭配就出现了，PS 和 PO 相对于 Serial 比较来说，就是垃圾回收的时候是使用的是多线程，其它的一样，包括使用的垃圾回收算法也一样，所以在多核时代，它相比 Serial STW 的时间变得更短了：

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WXvbGpopBhsibpVXMJ0EibA9AEpVDfPMsEczrTtcTANauajjibyuKbfN4g/640?wx_fmt=png)这里涉及到一个吞吐量的概念：**吞吐量 = 用户应用程序运行的时间 / （应用程序运行的时间 + 垃圾回收的时间）**，因为 PS+PO 的搭配是追求吞吐量的垃圾回收器。

因此 PS+PO 的组合比较适用于后台快速完成计算任务，不需要太多的与用户交互的场景。

与 PS+PO 有关的 JVM 参数如下所示：

*   **-XX: +UseParallelGC：开启 ParallelGC。**

*   **-XX: +UseParallelOldGC：开启老年代的 ParallelGC，和上面的任意开启一个就行。**

*   **-XX: ParallelGCThreads：指定线程数。**

*   **-XX：MaxGCPauseMillis：控制最大垃圾收集停顿时间（毫秒数）**

*   **-XX：GCTimeRatio：直接设置吞吐量大小（大于 0 小于 100 的整数）**

*   **-XX：+UseAdaptiveSizePolicy：当这个参数被激活后，就不需要制定新生代的大小（-Xmn）、Eden 和 S 区的比例（-XX：SurvivorRatio）、晋升老年代对象的大小（-XX：PretenureSizeThreshold）等参数，虚拟机会自己动态的调整。**


PS 和 PO 是 Java 8 默认的垃圾回收器，不知道各位读者的 Java 的版本是多少，已经使用 Java 8 好久了。

#### ParNew

ParNew 实际上和 Parallel 的实现原理基本相同，唯一不同的是它可以和 CMS 搭配使用，而 PS 是没办法与 CMS 搭配使用，这也使得 ParNew 火起来，当 JVM 中设置了使用 CMS 作为老年代的回收器的时候，新生代的垃圾回收器默认就是 ParNew。

#### CMS

CMS 可以说是跨时代的一款垃圾回收器，它实现了垃圾回收与用户线程并发进行，在它是一种以**获取最短垃圾停顿时间为目的的垃圾回收器**。

特别适用于**用户频繁交互的场景**，它的实现过程分为以下四个阶段：

*   **初始标记**

*   **并发标记**

*   **重新标记**

*   **并发清理**


其中初始标记和重新标记是需要 STW 的，而并发标记和并发清理垃圾回收线程与用户线程并发执行。

初始标记阶段仅仅是**标记 GC Root 直接关联的对象**，并不会遍历整个对象图，所以速度很快。

并发标记阶段就是从 **GC Root 开始遍历整个对象图的过程**，这个过程是四个阶段最耗时的过程，因此此阶段也是与用户线程并发执行的，不需要停顿用户线程。

重新标记阶段是**修正在并发标记阶段因用户线程运行产生一些对象的引用关系变动的标记记录**，因为在并发阶段用户线程与垃圾回收线程是并发执行的，那么就有可能之前已经标记的，它的引用关系又被改变了，这需要在这个阶段重新修正。

并发清理因为不用移动用户对象，因此可以与用户线程一起并发执行，最后清理掉不可达的对象。

四个阶段中其中最复杂的就是第三阶段并发标记，其中涉及到的一个重要概念就是**三色标记法**，第三阶段在标记的过程有可能对对象产生**漏标**或者**多标**的现象，那 CMS 又是怎么来解决这两个问题的呢？

我们先来详细了解一下三色标记法。三色标记法中将对象分为**白色、灰色、黑色**的过程。

*   **白色**：白色是**对象默认的颜色，从 GC Root 开始扫描，如果不可达的对象的就是白色**，在并发清理阶段就会被清理掉。

*   **灰色**：灰色表示**当前对象已经被扫描，但是当前对象所依赖的其他对象还没有被扫描。**

*   **黑色**：黑色表示**当前对象和它所依赖的对象都已经被扫描过。**


那它又是怎么产生多标和漏标的呢？下面来画图看看：

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3Wge84qF94KalYhxfw3ic1Xj3sFlTRW1T3ultANkU3eJB6SwMRBnsJItA/640?wx_fmt=png)

开始有三个对象，分别是对象 1 和对象 2 以及对象 3，三个对象与 GC Root 之间都存在引用链，当开始进行标记，就会从 GC Root 开始扫描。

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3Wfj5wb34M3gmia1SA6bhwOniaQ2EGy7IhiaMwauqsyP8manRNcgBSU5KrQ/640?wx_fmt=png)

当扫描了对象 1 和对象 2 的时候，因为对象 2 没有再依赖的引用，所以它会变成黑色，而对象 1 还引用着对象 3，并且对象 3 还没有扫描，所以对象 1 变成灰色。

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WLoZkA2lAdWBiag2bTB6AtKiamAkTaWoTzO2yHyzdejnm0VS7MibYNjgZA/640?wx_fmt=png)

若是，此时用户线程将对象 3 与对象 1 之间的引用关系改变了，变成了对象 2 与对象 3 之间有引用关系，因为对象 2 已经扫描完了，对象 3 还没扫描，此时应该是对象 2 是灰色的状态，并且对象 3 是白色的状态，对象 3 就会被回收掉，这就出现了漏标的情况。

![](https://mmbiz.qpic.cn/mmbiz_png/IJUXwBNpKljT9sbQfecxEhZoG86jKs3WaXlgkyLymkHk7kYdBGg799bb78DvnD1bh1zOnOeEgsITZx8Q4uh0cw/640?wx_fmt=png)

多标的情况就是当对象 1 和对象 3 之间开始有引用链，并且都已经标记为黑色，此时用户线程又把对象 3 设置为 null，那么此时按理来说对象 3 应该被回收的，但是因为是黑色并不会被回收掉，所以出现了多标，多标的情况可以在下次垃圾回收的时候，进行重新标记，被重新回收，所以多标并不会是 GC 回收的过程出现 bug。

而漏标就需要解决了，不然 GC 回收就会出现 bug，对于漏标 CMS 给出的解决方案是**增量更新**的方法。**它的原理就是假如对象 3 的引用变成了对象 2，那么对象 2 就会变成灰色，并且对象 2 会被集合里面，在重新标记的阶段以对象 2 为根节点向下扫描。**

这样 CMS 就解决漏标的问题，并且实现了整个 GC Root 对象图的时候，能够与用户线程并发执行，大大减少了 STW 的时间。

那为什么 CMS 又选择标记 - 清除算法呢？**因为假如选择标记 - 整理算法，在并发清理阶段因为要进行整理，涉及对象的移动，此时就不能与用户线程一起并发操作，这样清理阶段就必须 STW，就违背了 CMS 设计初衷：获取最短回收停顿时间。**

与 CMS 有关的 JVM 参数如下所示：

*   **-XX：+UseConcMarkSweepGC**：**使用 CMS 垃圾收集器**（当设置这个参数后，年轻代默认会开启 ParNew）。

*   **-XX:+UseCMSCompactAtFullCollection**：**用于在 CMS 收集器不得不进行 FullGC 时开启内存碎片的合并整理过程**，由于这个内存整理必须移动存活对象，清理阶段是无法并发的，此参数从 JDK9 开始废弃。

*   **-XX：CMSFullGCsBefore-Compaction**：**多少次 FullGC 之后压缩一次**，默认值为 0，表示每次进入 FullGC 时都进行碎片整理，此参数从 JDK9 开始废弃。

*   **-XX:CMSInitiatingOccupancyFraction**：当老年代使用达到该比例时会触发 FullGC，默认是 92。

*   **-XX:+UseCMSInitiatingOccupancyOnly**：这个参数搭配上面那个用，表示是不是要一直使用上面的比例触发 FullGC，如果设置则只会在第一次 FullGC 的时候使用 - XX:CMSInitiatingOccupancyFraction 的值，之后会进行自动调整。

*   **-XX:+CMSScavengeBeforeRemark**：在 FullGC 前启动一次 MinorGC，目的在于减少老年代对年轻代的引用，降低 CMSGC 的标记阶段时的开销，一般 CMS 的 GC 耗时 80% 都在标记阶段。

*   **-XX:+CMSParallellnitialMarkEnabled**：默认情况下初始标记是单线程的，这个参数可以让他多线程执行，可以减少 STW。

*   **-XX:+CMSParallelRemarkEnabled**：使用多线程进行重新标记，目的也是为了减少 STW。


CMS 的出现是有着非常重要的意义，它为后面更加智能的垃圾回收器 G1、ZGC 的出现奠定了基础，首次实现：**用户线程与垃圾回收线程并发执行**，但是慢慢的 CMS 也退出了舞台。

你会发现关于 CMS 的很多相关的 JVM 参数在 jdk9 已经废弃，并且在 jdk9，默认的垃圾回收器已经不再是 PS+PO 了，已经变成了 G1，说明 JVM 设计团队认为 G1 已经可以取代以前的垃圾回收器了（我还停留在 jdk8，手动狗头），我相信应该还有很多人在 jdk8 吧，哈哈哈。

#### G1

最后聊得就是 G1 了，G1 因为它的优势也成为了 jdk9 的默认垃圾回收器。它与其他的回收器不同的是，它将整个堆划分为很多个 Region，每个 Region 的大小大概在 1**M-32M** 之间。

它不在像以前的垃圾回收器一样将整个堆划分为年轻代和老年代，它的衡量标准是以哪块 Region 回收的利益最大，这就是 G1 的 **MixedGC** 模式。

G1 的阶段过程和 CMS 有异曲同工之妙，也是分为四个阶段：

*   **初始标记**

*   **并发标记**

*   **最终标记**

*   **筛选回收**


初始标记和 CMS 一样，需要 STW，只是**标记 GC Roots 直接关联的对象**，时间会非常的短。

并发标记也是与用户线程一起并发执行，**需要从 GC Root 开始遍历整个对象图**，也是消耗时间最长的阶段。

最终标记阶段用于**处理并发阶段结束后仍遗留下来的最后那少量的 SATB 记录，也就是并发标记阶段引用关系重新改变的对象**。

最后就是回收阶段，因为 G1 使用的是**标记 - 整理**算法，**所以涉及到对象的移动，所以这个阶段是需要 STW 的，必须暂停用户线程，由多条线程来执行垃圾回收。**

最后来聊一聊 G1 实现的一些小细节，一个是在并发标记阶段，它是怎么解决新对象内存分配的问题？另外一个最重要的细节就是它是怎么建立起可预估的停顿时间模型？在 G1 和 CMS 之间如何做选择呢？

先来看看第一个问题，在并发标记阶段用户线程也是在执行的，在执行就会产生新的对象，G1 是为每一个 Region 设计了两个名为 TAMS（TopatMarkStart）的指针。

并且把 Region 中的一部分空间划分出来用于新对象的内存分配，在并发回收时新分配的对象地址都必须要在这两个指针位置以上。

然后第二个细节就是 G1 在垃圾回收的过程中会记录每一个 Region 的回收耗时，花费的成本，并且根据多次计算出平均值，这样能够预估每一个 Region 的垃圾耗时，然后根据程序中设定的最短垃圾回收时间，估算回收哪一些 Region 是利益最大的。

那么在 G1 和 CMS 之间是如何进行选择的呢？对于小内存的（1G-4G）CMS 的可能会优于 G1，而对于大内存的（6G-8G）的可能 G1 就会显现出自己的优势。

最后与 G1 有关的 JVM 参数如下：

*   **-XX：G1HeapRegionSize**：设置每个 Region 的大小，取值范围为 1MB～32MB。

*   **-XX：MaxGCPauseMillis**：设置垃圾收集器的停顿时间，默认值是 200 毫秒。


好了有关于垃圾器的就聊到这里，还有一个也是比较经典的就是 ZGC，有兴趣的可以自行去了解一下，限于篇幅原因，这一片关于 JVM 的垃圾，我们就聊到这里，下一篇继续深入聊 JVM，我是黎杜，我们下一期见。

```
1.精心为你准备的最全的20道Mysql面试题。


2.万字好文，电商秒杀系统架构分析与实战！


3.面试官：你知道select语句和update语句分别是怎么执行的吗？

4.不懂分布式事务，别说你懂微服务！


5.【面经】深入Spring Cloud架构组成

6.深入理解：一文讲透RabbitMQ

7.SQL优化最干货总结-MySQL(2020最新版）

8.面试官：如何保障消息100%投递成功、消息幂等性？

9.通俗讲解分布式锁，看完不懂算作者输

黎杜编程
专注Java技术文章输出100年
73篇原创内容
公众号




你点的每个赞，我当做都认真
```