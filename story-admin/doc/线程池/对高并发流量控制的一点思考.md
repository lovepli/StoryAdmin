> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.jianshu.com](https://www.jianshu.com/p/d9504fc0af4d)

前言
==

在实际项目中，曾经遭遇过线上 5W+QPS 的峰值，也在压测状态下经历过 10W+QPS 的大流量请求，本篇博客的话题主要就是自己对高并发流量控制的一点思考。

应对大流量的一些思路
==========

> **首先，我们来说一下什么是大流量？**
>
> 大流量，我们很可能会冒出：TPS（每秒事务量），QPS（每秒请求量），1W+，5W+，10W+，100W+...。其实并没有一个绝对的数字，如果这个量造成了系统的压力，影响了系统的性能，那么这个量就可以称之为大流量了。
>
> **其次，应对大流量的一些常见手段是什么？**
>
> **缓存**：说白了，就是让数据尽早进入缓存，离程序近一点，不要大量频繁的访问 DB。
>
> **降级**：如果不是核心链路，那么就把这个服务降级掉。打个比喻，现在的 APP 都讲究千人千面，拿到数据后，做个性化排序展示，如果在大流量下，这个排序就可以降级掉！
>
> **限流**：大家都知道，北京地铁早高峰，地铁站都会做一件事情，就是限流了！想法很直接，就是想在一定时间内把请求限制在一定范围内，保证系统不被冲垮，同时尽可能提升系统的吞吐量。
>
> **注意到，有些时候，缓存和降级是解决不了问题的，比如，电商的双十一，用户的购买，下单等行为，是涉及到大量写操作，而且是核心链路，无法降级的，这个时候，限流就比较重要了。**
>
> 那么接下来，我们重点说一下，限流。

限流的常用方式
=======

> 限流的常用处理手段有：计数器、滑动窗口、漏桶、令牌。

### **计数器**

> **计数器是一种比较简单的限流算法，用途比较广泛，在接口层面，很多地方使用这种方式限流。在一段时间内，进行计数，与阀值进行比较，到了时间临界点，将计数器清 0。**

![](http://upload-images.jianshu.io/upload_images/4943997-62f4632ae3cb0244.png) 计数器思想

代码实例

![](http://upload-images.jianshu.io/upload_images/4943997-c9d606d28dfe363e.png) 计数器代码实现

> 这里需要注意的是，存在一个时间临界点的问题。举个栗子，在 12:01:00 到 12:01:58 这段时间内没有用户请求，然后在 12:01:59 这一瞬时发出 100 个请求，OK，然后在 12:02:00 这一瞬时又发出了 100 个请求。这里你应该能感受到，在这个临界点可能会承受恶意用户的大量请求，甚至超出系统预期的承受。

### **滑动窗口**

> **由于计数器存在临界点缺陷，后来出现了滑动窗口算法来解决。  
> **

![](http://upload-images.jianshu.io/upload_images/4943997-1ead1427043f0575.png) 滑动窗口原理图

> **滑动窗口的意思是说把固定时间片，进行划分，并且随着时间的流逝，进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。**

### **漏桶**

> 虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。
>
> **有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。**

![](http://upload-images.jianshu.io/upload_images/4943997-ca546bf3163079ea.png) 漏桶算法思想

代码实现

![](http://upload-images.jianshu.io/upload_images/4943997-d20d59ede8f0f2f8.png) 漏桶代码实现

**令牌桶**

> 注意到，漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。为了解决这个问题，令牌桶进行了算法改进。

![](http://upload-images.jianshu.io/upload_images/4943997-2a0b50e0cc9d4705.png) 令牌桶原理

> **生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。（有一点生产令牌，消费令牌的意味）**
>
> **不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量，这是合理的，如果因为极少部分流量需要保证的话，那么就可能导致系统达到极限而挂掉，得不偿失。**

代码实现

![](http://upload-images.jianshu.io/upload_images/4943997-ab905dded8c2f8df.png) 令牌桶代码实现

限流神器：Guava RateLimiter
======================

> Guava 不仅仅在集合、缓存、异步回调等方面功能强大（可以参考博主的[《使用 Google Guava 快乐编程》](https://www.jianshu.com/p/97778b21bd00)），而且还给我们封装好了限流的 API！
>
> Guava RateLimiter 基于令牌桶算法，我们只需要告诉 RateLimiter 系统限制的 QPS 是多少，那么 RateLimiter 将以这个速度往桶里面放入令牌，然后请求的时候，通过 tryAcquire() 方法向 RateLimiter 获取许可（令牌）。

代码示例

![](http://upload-images.jianshu.io/upload_images/4943997-153e571a23efce19.png) RateLimiter

分布式场景下的限流
=========

> **上面所说的限流的一些方式，都是针对单机而言的，其实大部分的场景，单机的限流已经足够了。分布式下限流的手段常常需要多种技术相结合，比如 Nginx+Lua，Redis+Lua 等去做。本文主要讨论的是单机的限流，这里就不在详细介绍分布式场景下的限流了。**
>
> **一句话，让系统的流量，先到队列中排队、限流，不要让流量直接打到系统上。**

**好了，到这里，本文就结束了！**

**早安！**

**美好的一天开始了，上班咯！**