<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.story.storyadmin.mapper.sysmgr.RoleAuthorityMapper">

<!-- 角色权限信息：开启二级缓存 -->
<cache type="org.mybatis.caches.ehcache.LoggingEhcache"/>

    <!--根据角色ID获取权限 注意：权限ID的值不为权限表中父ID的值-->
    <select id="selectAuthByRoleId0" resultType="Long">
        SELECT
          authority_id
        FROM  st_role_authority
        where role_id= #{roleId}
              and yn_flag='1'
              and authority_id not in (select distinct pid from st_authority where yn_flag='1')
    </select>

<!--对sql进行优化，使用 not exists() 替换 not in-->
    <select id="selectAuthByRoleId" resultType="Long">
        SELECT
        ra.authority_id
        FROM  st_role_authority ra
        where ra.role_id= #{roleId}
        and ra.yn_flag='1'
        and not exists (select 1 from st_authority ta where ta.yn_flag='1' and  ta.pid= ra.authority_id  )
    </select>


    <!-- EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，但要看实际情况具体使用：
    IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。   -->
<!--in、not in、exists和not exists的区别： 参考：https://www.cnblogs.com/qlqwjy/p/8598091.html
先谈谈in和exists的区别：
exists:存在，后面一般都是子查询，当子查询返回行数时，exists返回true。

当in和exists在查询效率上比较时，in查询的效率快于exists的查询效率
exists(xxxxx)后面的子查询被称做相关子查询, 他是不返回列表的值的.
只是返回一个ture或false的结果(这也是为什么子查询里是select 'x'的原因 当然也可以select任何东西) 也就是它只在乎括号里的数据能不能查找出来，是否存在这样的记录。
其运行方式是先运行主查询一次 再去子查询里查询与其对应的结果 如果存在，返回ture则输出,反之返回false则不输出,再根据主查询中的每一行去子查询里去查询.

in()后面的子查询 是返回结果集的,换句话说执行次序和exists()不一样.子查询先产生结果集,然后主查询再去结果集里去找符合要求的字段列表去.符合要求的输出,反之则不输出.

not in和not exists的区别：
not in 只有当子查询中，select 关键字后的字段有not null约束或者有这种暗示时用not in,另外如果主查询中表大，子查询中的表小但是记录多，则应当使用not in,

not in的执行顺序是：是在表中一条记录一条记录的查询(查询每条记录）符合要求的就返回结果集，不符合的就继续查询下一条记录，直到把表中的记录查询完。也就是说为了证明找不到，所以只能查询全部记录才能证明。并没有用到索引。
not exists：如果主查询表中记录少，子查询表中记录多，并有索引。

not exists的执行顺序是：在表中查询，是根据索引查询的，如果存在就返回true，如果不存在就返回false，不会每条记录都去查询。
之所以要多用not exists，而不用not in，也就是not exists查询的效率远远高与not in查询的效率。

-->

    <!--根据RoleID删除-->
    <update id="deleteAuthByRoleId" parameterType="com.story.storyadmin.domain.entity.sysmgr.RoleAuthority">
      update st_role_authority set yn_flag='0',
      editor=#{editor},
      modified_time=#{modifiedTime}
      where role_id= #{roleId}
            and yn_flag='1'
    </update>


    <!--批量新增-->
    <insert id="batchInsert" parameterType="java.util.List" useGeneratedKeys="false">
      insert into st_role_authority(role_id,authority_id,yn_flag,creator,editor,created_time,modified_time)
      values
        <foreach collection="list" item="item" index="index" separator=",">
          (
            #{item.roleId},
            #{item.authorityId},
            #{item.ynFlag},
            #{item.creator},
            #{item.editor},
            #{item.createdTime},
            #{item.modifiedTime}
          )
        </foreach>
    </insert>



</mapper>
