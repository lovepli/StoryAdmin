package com.story.storyadmin.设计模式.原型模式;

/**
 * @author: lipan
 * @date: 2021/8/23
 * @description:
 */
public class Demo {
    /**
     * 原型模式定义
     * 大致意思：用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。
     *
     * 原型模式：Prototype Pattern，属于创建型模式。
     *
     * 调用者不需要知道任何创建细节，也不用调用构造方法来创建对象。
     *
     * 使用场景
     * 原型模式有如下使用场景：
     *
     * 类初始化消耗资源较多
     * new产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）
     * 构造函数比较复杂
     * 循环体内生成大量对象时
     * 在Spring中，原型模式应用的非常广泛，例如:scope='prototype'
     * 我们可以将一些getter和setter之类封装成一个工厂方法，然后对于使用的人来说，调用方法就可以了，不需要知道里面的getter和setter是怎么处理的。我们也可以使用JDK提供的实现Cloneable接口，实现快速复制。
     *
     * 创建对象的四种方式：
     *
     * new、反射、克隆、序列化
     *
     * 实际案例
     * 大家是否有遇到过这种常见，就是项目中规定，不能把与数据库表映射的entity类返回给前端，所以通常返回给前端的有各种O，比如：XxxVO、XxxBO、XxxDTO...
     *
     * 这时候就会出现下面的场景，大家也想已经猜到了。
     *
     *
     *
     *
     * 总结
     * 切记：深和浅，指的是克隆对象里的属性（引用类型）是否指向同一个内存地址。
     *
     * 为了更深刻的理解深克隆和浅克隆，我们回答文中的简历拷贝的故事。
     *
     * 深拷贝：拷贝一份简历，然后对简历中的信息进行修改成自己的
     * 浅拷贝：拷贝一份简历，简历内容完全不变
     * 优点：
     *
     * Java 原型模式基于内存二进制流复制，比直接 new 的性能会更好一些。
     * 可以利用深克隆保存对象状态，存一份旧的（克隆出来），在对其修改，可以充当一个撤销功能。
     * 缺点：
     *
     * 需要配置 clone 方法，改造时需要对已有类进行修改，违背 “开闭原则”。
     * 如果对象间存在多重嵌套引用时，每一层都需要实现克隆。
     * 我们从原型模式的定义，使用场景，真实案例、浅克隆、深克隆、优缺点等方面，对原型模式进行了一个全面的讲解。
     *
     * 一句话总结：
     *
     * 一份简历，全班同学用
     */
}
