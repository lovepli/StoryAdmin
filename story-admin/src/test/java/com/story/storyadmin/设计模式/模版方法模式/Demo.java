package com.story.storyadmin.设计模式.模版方法模式;

/**
 * @author: lipan
 * @date: 2021/8/22
 * @description:
 */
public class Demo {

    /**
     * 概述
     * 模板模式就是定义一个操作中的算法骨架，然后将一些步骤延迟到子类中。
     * 模板方法使得子类在不改变算法的结构即可重定义该算法的某些步骤。
     *
     * 使用场景
     * 喝茶水
     * 我们都知道泡茶基本步骤（算法骨架）有：
     *
     * 烧水、泡茶、喝茶水。
     * 整个过程中很关键的步骤是泡茶，泡茶需要跑什么茶呢？泡多久？（留给子类自己去实现）。
     *
     * API
     * 写过API接口的码友们都知道，写API一般有四个步骤：
     *
     * 参数解析、参数校验、处理业务、组织返回参数。
     *
     * 把请求参数解析成该业务的请求参数json解析成实体类；参数校验，您可以使用通用的方式就是判断参数是否为空，也可以自己定义特殊的校验方式；处理业务一般每个接口都是不一样的，基本上都是自己去实现；至于返回参数，可能您得根据该API接口业务来返回。
     *
     * 支付订单
     * 做过支付相关的系统的人都清楚，支付订单大致分这三个步骤：
     *
     * 组织请求银行或者第三方支付公司的请求参数、发起支付、处理返回结果。
     *
     * 以上三个场景中的步骤就是算法骨架，至于每个步骤可能每个人喝茶偏好不一样，API接口业务不一样、银行或者第三方支付的支付处理不一样，可能需要自己做特殊的处理。
     *
     *
     *
     * 参数校验也可以在 AbstractTemplate  中实现一个 default   的方式，比如说：校验参数是否为空，但是子类也可以重写这个方法，自己做一个特殊的校验；比如说：如果参数中有手机号码，那么我们不仅要校验手机号是否为空，还可以校验这个手机号码是不是11位，是否合法的校验等等。
     *
     * 模板模式优缺点
     * 优点
     * 提高代码的复用性，将相同部分的代码放到抽象类里；
     * 提高拓展性，将不同的放到不同的实现类里，通过实现类的扩展增加一些自己需要的行为；
     * 实现反向控制，通过一个父类调用实现类的操作，通过对实现类的扩展增加新行为，实现反向控制。
     *
     * 缺点
     * 因为引入了抽象类，每个不同的实现都需要一个子类来现实，这样会导致类的数量增多，从而导致系统实现的复杂度。
     */
}
