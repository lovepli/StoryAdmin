package com.story.storyadmin.设计模式.门面模式;

/**
 * @author: lipan
 * @date: 2021/8/22
 * @description:
 */
public class Demo {

    /**
     * 门面模式概述
     * 门面模式（Facade Pattern）又叫作外观模式，提供了一个统一的接口，用来访问子系统中的一群接口。其主要特征是定义了一个高层接口，让子系统更容易使用，属于结构型设计模式。
     *
     *
     * 其实，在日常编码工作中，我们都在有意无意地大量使用门面模式。但凡只要高层模块需要调度多个子系统（2个以上类对象），我们都会自觉地创建一个新类封装这些子系统，提供精简的接口，让高层模块可以更加容易地间接调用这些子系统的功能。
     *
     *
     * 生活中的案例
     * 关于门面模式，在生活中的案例，非常之多。
     *
     * 案例1：去银行办理业务，有个前台接待你，然后，这个前台会问你需要办什么业务，他会一个一个带你办理，这样我们就不需要到处乱串、到处找对应业务窗口了。这个前台人员就相当于门面模式。
     *
     * 案例2：我们建房子，如果没有包工头的话，那就是你自己要去找水泥工，电工、装修工等。但如果有了包工头，这些活你都不用干了，直接跟包工头说，需要电工来把线路搞好。这个包工头就可以理解为门面模式。
     *
     * 案例3：我们后端开发的controller，也可以理解为门面模式，比如说获取用户账户信息，先查UserService获取用户信息，然后查UserAccountService用户账户信息。
     *
     * 门面模式适用场景
     * 在软件系统中，门面模式适用于以下应用场景。
     *
     * 为一个复杂的模块或子系统提供一个简洁的供外界访问的接口。
     * 希望提高子系统的独立性时。
     * 当子系统由于不可避免的暂时原因导致可能存在Bug或性能相关问题时，可以通过门面模式提供一个高层接口，隔离客户端与子系统的直接交互，预防代码污染。
     *
     * 门面模式中的角色
     * 由上图可以看到，门面模式主要包含2个角色。
     *
     * 外观角色（Facade）：也叫作门面角色，是系统对外的统一接口。
     * 子系统角色（Service）：可以同时有一个或多个Service。每个Service都不是一个单独的类，而是一个类的集合。Service们并不知道Facade的存在，对于Service们而言，Facade 只是另一个客户端而已（即Facade对ServiceA、ServiceB、ServiceC透明）。
     * 门面模式的扩展
     * 优点
     * ● 减少系统的相互依赖 　　想想看，如果我们不使用门面模式，外界访问直接深入到子系统内部，相互之间是一种强耦合关系，你死我就死，你活我才能活，这样的强依赖是系统设计所不能接受的，门面模式的出现就很好地解决了该问题，所有的依赖都是对门面对象的依赖，与子系统无关。
     * ● 提高了灵活性 　　依赖减少了，灵活性自然提高了。不管子系统内部如何变化，只要不影响到门面对象，任你自由活动。
     * ● 提高安全性 　　想让你访问子系统的哪些业务就开通哪些逻辑，不在门面上开通的方法，你休想访问到 。
     *
     * 缺点
     * 当增加子系统和扩展子系统行为时，可能容易带来未知风险。
     * 不符合开闭原则。
     * 某些情况下，可能违背单一职责原则。
     */
}
