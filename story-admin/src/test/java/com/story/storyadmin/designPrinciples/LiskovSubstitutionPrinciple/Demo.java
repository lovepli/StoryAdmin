package com.story.storyadmin.designPrinciples.LiskovSubstitutionPrinciple;

/**
 * @author: lipan
 * @date: 2021/8/19
 * @description:
 */
public class Demo {

/**
 * 里氏替换原则
 * 定义
 * 里氏替换原则（Liskov Substitution Principle，LSP）指如果对每一个类型为T1的对象O1，都有类型为T2的对象O2，使得以T1定义的所有程序P在所有对象O1都替换成O2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。
 *
 * 定义看上去比较抽象，我们重新解释一下，可以理解为一个软件实体如果适用于一个父类，则一定适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。也可以理解为，子类可以扩展父类的功能，但不能改变父类原有的功能。根据这个理解，我们对里氏替换原则的定义总结如下。
 *
 * （1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
 *
 * （2）子类中可以增加自己特有的方法。
 *
 * （3）当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松。
 *
 * （4）当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类的方法更严格或相等。
 * 一句话概括：
 * 子类接收的参数(类型)范围比父类大，返回大类型范围比父类小。可以理解为子类比父类强，父亲能干的事情儿子一定可以，反过来不一定成立。
 * 子类可以扩展父类的功能，但不能改变父类原有的功能
 *
 *
 *
 *
 * 参考：https://blog.csdn.net/zhengzhb/article/details/7281833
 * 定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。
 *
 * 定义2：所有引用基类的地方必须能透明地使用其子类的对象。
 *
 * 问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。
 *
 * 解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
 *
 * 继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。
 *
 * 继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。
 *
 * 里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：
 *
 * 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
 * 子类中可以增加自己特有的方法。
 * 当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
 * 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
 */
}
